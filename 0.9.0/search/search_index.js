var __index = Promise.resolve({"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+","tags":false},"docs":[{"location":"","text":"","title":"Overview"},{"location":"#welcome-to-leapp","text":"<p>Leapp is a tool for developers to manage, secure, and access the cloud.</p> <p>All data is persisted and encrypted on your workstation. Head to our Security section to know how we guarantee the highest level of security.</p>   Leapp Main Window  <p>The name Leapp is based on the word leap and is pronounced /l:ip/. We chose this name because the project enables you to be one step away from your cloud environments.</p>","title":"Welcome to Leapp"},{"location":"configuration/","text":"<p>Now it's time to add your very first configuration, follow the link to your preferred supported method and start enjoying Leapp. </p>","title":"Add your first configuration"},{"location":"configuration/#sessions","text":"","title":"Sessions"},{"location":"configuration/#aws","text":"<p>Select the configuration you need from the Access Method dropdown menu:</p> <p></p> <p>Then follow the links below.</p>","title":"AWS"},{"location":"configuration/#configure-an-aws-iam-user","text":"","title":"Configure an AWS IAM User"},{"location":"configuration/#configure-an-aws-iam-role-federated","text":"","title":"Configure an AWS IAM Role Federated"},{"location":"configuration/#configure-an-aws-iam-role-chained","text":"","title":"Configure an AWS IAM Role Chained"},{"location":"configuration/#azure","text":"","title":"Azure"},{"location":"configuration/#configure-an-azure-tenant","text":"","title":"Configure an Azure Tenant"},{"location":"configuration/#integrations","text":"","title":"Integrations"},{"location":"configuration/#configure-aws-sso","text":"","title":"Configure AWS SSO"},{"location":"integrations/","text":"<p>This section provides an overview of Leapp's integrations, useful to extend the functionality of Leapp to 3rd party services.</p> <p>Integrations help manage access and identities on your preferred service of choice and use Leapp on your daily activities by automatically mapping them into Sessions.</p> <p>Integrations help manage access and identities on your service of choice while using Leapp during your daily activities. They are automatically mapped into Sessions.</p>","title":"Integrations"},{"location":"integrations/#actions","text":"<p>Integrations have four main actions available: Create, Delete, Sync, and Logout.</p>    Action Description     <code>CREATE</code> Configure a new Integration with the data needed to start the authentication flow. Required to Sync and map the service response into Sessions.   <code>DELETE</code> Remove an existing Integration. Removes all the associated Sessions as well and wipes everything related to the Integration from the system (tokens, cache, etc.)   <code>SYNC</code> Start the authentication flow to log into the Integration Provider. Leapp will automatically retrieve all the related data and map the response into Sessions. Any change in your service of choice requires a manual Sync to reflect the current status.   <code>LOGOUT</code> Disable the Integration. Removes all the Sessions but keeps the Integration data. Running a Sync will restore all the Sessions tied to it.","title":"Actions"},{"location":"integrations/#supported-services","text":"Service Supported     AWS SSO    Okta Coming Soon   OneLogin Coming Soon   AzureAD Coming Soon","title":"Supported Services"},{"location":"sessions/","text":"<p>A Session contains all the relevant information to let the dev connect to a cloud provider. Three standard actions should be implemented for each session: start, stop, and rotate.</p>","title":"Sessions"},{"location":"sessions/#actions","text":"Method Description     <code>START</code>     \u00a0Make the temporary credentials available to the provider chain   <code>STOP</code>     \u00a0Removes the temporary credentials from the provider chain   <code>ROTATE</code> :fontawesome-solid-undo:    \u00a0Generate new temporary credentials, and substitute the previous ones in the provider chain","title":"Actions"},{"location":"sessions/#session-model-data","text":"<p>All Sessions Models share some basic information, common to all of them. These variables must always be defined.</p>  Info <p>The process of setting up Leapp Sessions is managed either manually, for each access method, or through integrations with third-party tools. Leapp stores all the Sessions available to the users locally, inside a configuration file called Workspace.</p>  <pre><code>...\nexport class Session {\n\n  sessionId: string;\n  sessionName: string;\n  status: SessionStatus;\n  startDateTime: string;\n  region: string;\n  type: SessionType;\n\n  ...\n}\n</code></pre>    Session Variable Description     <code>sessionId</code> A Unique identifier for the Session. It is defined at Model instantiation, and represents a unique ID for the session. Every operation involving a specific session must start by getting a session through its <code>sessionId</code>   <code>sessionName</code> A fancy name, chosen by the user when creating the Session, to make it recognizable at first glance.   <code>status</code> Represents the State Management of a single session; when the status of a session is <code>active</code>, temporary credentials are available to the user. The possible values are: <code>inactive</code>, <code>pending</code>, <code>active</code>   <code>startDateTime</code> A UTC DateTime string representing the last time a specific Session has started; this is useful for rotation and sorting purposes   <code>region</code> The AWS Region or Azure Location the Session is working on. For a complete list of AWS Regions go here, and for Azure Locations, go here   <code>type</code> Uniquely identifies two important aspects to determine the Session: Cloud Provider and Access Method.. Possible values are: <code>awsIamRoleFederated</code>, <code>awsIamUser</code>, <code>awsIamRoleChained</code>, <code>awsSsoRole</code>, <code>azure</code>. The naming convention we are using is cloudProvider-accessMethod: Cloud Provider on which you are connecting (i.e., AWS, Azure, GCP...), and the Access Method used to generate credentials (i.e., AWS IAM User, Azure Tenant, AWS IAM Role...)","title":"Session Model Data"},{"location":"built-in-features/aws-ec2-connect/","text":"<p>You can directly connect to an AWS EC2 instance from Leapp through AWS System Manager (AWS SSM).</p>  <p>Info</p> <p>To setup SSM follow this guide.</p>      <p>To correctly connect follow these steps:</p> <ol> <li>Right-click on a suitable AWS session to open the contextual menu</li> <li>Click on View SSM sessions</li> <li>Select the AWS region in which your instance is located</li> <li>Wait for Leapp to load your instances</li> <li>Select the instance and click connect</li> <li>Wait for the terminal to open</li> <li>Focus the terminal window and write <code>/bin/bash</code>; press  Enter  and you'll be inside the terminal of your Instance</li> </ol>     <p>Warning</p> <p>If the user is not granted the right permissions, the operation will fail and Leapp will throw an error message.</p>","title":"EC2 connect through AWS SSM"},{"location":"built-in-features/aws-named-profiles/","text":"<p>With Leapp you can group and activate more than one credential set at a time through Named Profiles.</p>","title":"AWS Multi-profile management"},{"location":"built-in-features/aws-named-profiles/#named-profiles","text":"<p>Named Profiles are used by AWS to maintain more than one set of active credentials for you to use with AWS-CLI, SDK, or other third-party tools. Named profiles are stored in ~/.aws/credentials file in the ini file format.</p> <p>Named Profiles have a default profile which is the one you get from aws configure command.</p>","title":"Named Profiles"},{"location":"built-in-features/aws-named-profiles/#create-a-new-named-profile","text":"<p>Named Profiles can be created in 3 ways:</p> Option PanelWhen creating a new SessionEdit Profile in Contextual Menu   <p>Click on the gear icon   and select the Profiles tab. Insert the name of the new Named Profile in the input form, then click on the plus icon.</p>   <p>When creating a new session, the user will have the option to choose a Named Profile or add a new one.</p>   <p>Right-click on a session and select Change then Named Profile: an option to select or add a new Named Profile will be available.  </p>    <p>The new name is directly added to the Named Profile list and can then be used for other sessions too.</p>  <p>Info</p> <p>AWS SSO sessions will have the Named Profile <code>default</code> when obtained via Login or Sync. To change the Named Profile associated to a session you have to use the \"Change Profile\" option in the session list.</p>","title":"Create a new Named Profile"},{"location":"built-in-features/aws-named-profiles/#named-profile-list","text":"<p>Named profiles can be managed from the Option menu.</p> <p>In the Option menu, under the Profiles tab, you can add or edit a new Named Profile, and you can also remove unwanted ones. When removing a Named Profile, Leapp will warn you about which sessions are using that profile, and those sessions will be reverted to the default Named Profile.</p> <p>The input form can be used to add or edit a Named Profile: if it's empty, you can use it to add a new named profile. When selecting the  button, you will be able to edit the name of the Named Profile from within the input form.</p>  <p>Warning</p> <p>Remember that when you change the profile of a session, the session will be immediately put in stop mode. That's because Leapp would have to change the credential file, so you will need to restart the session again.</p>","title":"Named Profile List"},{"location":"configuring-integration/configure-aws-single-sign-on-integration/","text":"<p>AWS Single Sign-On (AWS SSO) is a cloud service that allows you to grant your users access to AWS resources across multiple AWS accounts.</p> <p>AWS SSO provides a directory that you can use to create users, organize them in groups, and set permissions across those groups; alternatively, you can obtain them from your Microsoft Active Directory or any standards-based identity provider, such as Okta Universal Directory or Azure AD.</p> <p>After logging in the first time, Leapp will map all your roles and users into Sessions.  </p>  <p>Info</p> <p>To get started using AWS SSO refer to this guide.</p>","title":"Configure AWS Single Sign-On integration"},{"location":"configuring-integration/configure-aws-single-sign-on-integration/#fields","text":"Field Description     <code>AWS SSO URL</code> The portal URL to begin the authentication flow. It usually follows this pattern: <code>d-xxxxxxxxxx.awsapps.com/start</code>.   <code>REGION</code> The region on which AWS SSO is administered and configured. This is NOT where your generated credentials will be valid, it's only used for the login part.","title":"Fields"},{"location":"configuring-integration/configure-aws-single-sign-on-integration/#video-tutorial","text":"","title":"Video Tutorial"},{"location":"configuring-session/configure-aws-iam-role-chained/","text":"<p>An IAM role has some similarities to an IAM user. Roles and users are both AWS identities with permissions policies that determine what the identity can and cannot do in AWS. However, instead of being uniquely associated with one person, a role is intended to be assumable by anyone who needs it.</p> <p>A role does not have standard long-term credentials such as a password or access keys associated with it. Instead, when you assume a role, it provides you with temporary security credentials for your role session.</p> <p>Role chaining occurs when you use a role to assume a second role through the AWS CLI or API, even in other accounts.</p>  <p>Info</p> <p>Refer to this guide to delegate access across AWS accounts using IAM Roles chaining.</p>","title":"Configure AWS IAM Role Chained"},{"location":"configuring-session/configure-aws-iam-role-chained/#fields","text":"Field Description     <code>SESSION ALIAS</code> Your friendly session name in Leapp. Give it a meaningful name so it will be easier to find inside Leapp.   <code>NAMED PROFILE</code> Your friendly session name in the AWS credential file. You will be able to reference it from the AWS CLI with <code>--name</code>.   <code>REGION</code> Your default region of choice. Select the one which you use the most for this Session.   <code>ROLE ARN</code> Your IAM Role unique ID. The active Session will refer to this Role.   <code>ROLE SESSION NAME</code> Your session name. You can query and search this on AWS Cloudtrail or any other linked audit service to find out what action were performed by the linked Identity.   <code>ASSUMER SESSION</code> Your session from which this Role will be assumed. The <code>assume-role</code> call will be automatically made by Leapp.","title":"Fields"},{"location":"configuring-session/configure-aws-iam-role-chained/#video-tutorial","text":"","title":"Video Tutorial"},{"location":"configuring-session/configure-aws-iam-role-federated/","text":"<p>AWS Identity and Access Management (IAM) supports identity federation for delegated access to the AWS Management Console or AWS APIs. With identity federation, external identities are granted secure access to resources in your AWS accounts through IAM roles.</p> <p>These external identities can come from your corporate identity provider (such as Microsoft Active Directory or from the AWS Directory Service) or from a web identity provider (such as Amazon Cognito, Login with Amazon, Facebook, Google, or any OpenID Connect-compatible provider).</p> <p>We currently only support SAML 2.0 federation.</p>  <p>Info</p> <ul> <li>Refer to this guide to provision your own federated roles.</li> <li>Refer to this guide to configure and trust your SAML 2.0 Identity Provider.</li> </ul>","title":"Configure AWS IAM Role Federated"},{"location":"configuring-session/configure-aws-iam-role-federated/#supported-saml-identity-providers","text":"Identity Provider AWS Azure     <code>GSUITE</code>     <code>OKTA</code>     <code>ONELOGIN</code>     <code>AZURE AD</code>","title":"Supported SAML Identity Providers"},{"location":"configuring-session/configure-aws-iam-role-federated/#fields","text":"Field Description     <code>SESSION ALIAS</code> Your friendly session name in Leapp. Give it a meaningful name so it will be easier to find inside Leapp.   <code>NAMED PROFILE</code> Your friendly session name in the AWS credential file. You will be able to reference it from the AWS CLI with <code>--name</code>.   <code>REGION</code> Your default region of choice. Select the one which you use the most for this Session.   <code>SAML 2.0 URL</code> Your SAML URL interface to start the authentication flow and log into your Identity provider.   <code>AWS IDENTIY PROVIDER ARN</code> Your Identity Provider ID in AWS. You can find it in IAM section Identity Providers.   <code>ROLE ARN</code> Your IAM Role unique ID. The active Session will refer to this Role.","title":"Fields"},{"location":"configuring-session/configure-aws-iam-role-federated/#video-tutorial","text":"","title":"Video tutorial"},{"location":"configuring-session/configure-aws-iam-user/","text":"<p>An AWS Identity and Access Management (IAM) user is an entity that you create in AWS to represent the person or application that uses it to interact with AWS.</p> <p>An IAM User in AWS consists of a name and a set of long-term credentials. Leapp never sets these values in the configuration files, and automatically generates and refreshes a set of short-term credentials.</p>  <p>Info</p> <p>If you want to know how Leapp generates and refresh short-term credentials refer to the credentials generation section in the documentation.</p>","title":"Configure AWS IAM User"},{"location":"configuring-session/configure-aws-iam-user/#fields","text":"Field Description     <code>SESSION ALIAS</code> Your friendly session name in Leapp. Give it a meaningful name so it will be easier to find inside Leapp.   <code>NAMED PROFILE</code> Your friendly session name in the AWS credential file. You will be able to reference it from the AWS CLI with <code>--name</code>.   <code>REGION</code> Your default region of choice. Select the one which you use the most for this Session.   <code>MFA DEVICE</code> Your MFA device ID to set up multi-factor authentication.   <code>ACCESS KEY ID</code> Your long-term Access Key. It will be used to generate a short-term set of credentials. Don't disclose it to anyone.   <code>SECRET ACCESS KEY</code> Your long-term Secret Key. It will be used to generate a short-term set of credentials. Don't disclose it to anyone.      Add AWS IAM User Screen","title":"Fields"},{"location":"configuring-session/configure-aws-iam-user/#video-tutorial","text":"","title":"Video Tutorial"},{"location":"configuring-session/configure-azure-tenant/","text":"<p>A dedicated and trusted instance of Azure AD that's automatically created when your organization signs up for a Microsoft cloud service subscription, such as Microsoft Azure, Microsoft Intune, or Microsoft 365. An Azure tenant represents a single organization.</p> <p>An Azure Tenant consists of a name and a set of long-term credentials. </p>  <p>Info</p> <p>For azure-cli version &lt; 2.30.0: Leapp enhances security of Azure credentials by removing refresh token from the accessTokens.json file  which could potentially allow an attacker accessing a User's PC to regenerate valid credentials even  if a valid access token is not present and by rotating Azure access token.</p>","title":"Configure Azure Tenant"},{"location":"configuring-session/configure-azure-tenant/#fields","text":"Field Description     <code>SESSION ALIAS</code> Your friendly session name in Leapp. Give it a meaningful name so it will be easier to find inside Leapp.   <code>TENANT ID</code> A tenant ID identifies a tenant. You can have multiple clients on a given tenant database.   <code>SUBSCRIPTION ID</code> The subscription ID is a unique alphanumeric string that identifies your Azure subscription.   <code>LOCATION</code> The Azure datacenters are located around the world in strategic places that best meet the customer demands. These areas are known as Azure locations. Specific services requires the user to select a specific location.","title":"Fields"},{"location":"configuring-session/configure-azure-tenant/#video-tutorial","text":"","title":"Video Tutorial"},{"location":"contributing/get-involved/","text":"<p>Contributions and questions are not just welcome, they\u2019re essential! Please open issues with ideas on how to improve Leapp, including feedback, critiques, and information about how you\u2019re using it. Discussion is at the heart of the project and your thoughts and ideas will help make it better for everyone, thank you. </p> <p>Read our contribution guide to learn more.</p> <p>You can chat with us in our community, so join us, or feel free to contact us via the website!</p> <p>Join our Community </p>","title":"Get involved"},{"location":"contributing/project-structure/","text":"<p>To allow what is proposed in the Specs, Leapp's project is built on a set of services that realize the basic functionalities.</p> <p>The actual project's structure is structured to allow developers to contribute to source code in the most easier and atomic way possible.</p> <p>In particular, we want to focus the attention on the development of Session Service patterns:</p>","title":"Overview"},{"location":"contributing/project-structure/#session-service-pattern","text":"<p>A specific service manages the way each type of Session will handle the process of credentials generation.</p>     <p>There is a three-level abstraction implementation for this kind of service:</p> <ul> <li>A general Session Service is the top level of abstraction of a Session, it implements the state management of any Session in the app and has three abstract methods for Start, Stop, and Rotate.</li> <li>A Provider Session Service  (i.e., AWSSessionService) extends the general session service and handles credentials for a specific Cloud Provider to Start, Stop, and Rotate each Session of this type. This level of abstraction unifies all the common actions for all the Access Methods within a Cloud Provider.</li> <li>A  Provider Access Method Service (i.e., AWSIAMUserService) is the concrete implementation of all the information needed to generate the credentials for a specific Access Method. It implements both CRUD methods and the specific steps to generate credentials for a given Access Method.</li> </ul>","title":"Session Service Pattern"},{"location":"contributing/project-structure/#aws-example","text":"<p>Leapp manages on behalf of a user the <code>~./aws/credentials</code> file.</p> <p>It leverages Start, Stop, and Rotate methods from basic Session Service to add, remove, or renew temporary credentials in the file.</p> <p>Based on the Session Service Pattern, we created the Aws Session Service to extend basic Session Service for AWS.</p>","title":"AWS example"},{"location":"contributing/project-structure/#awssessionservice-provider-service","text":"<p>AwsSessionService was created because all the Access Methods for AWS implemented in Leapp shares a common code structure for Start, Stop, and Rotate.</p> <p>AwsSessionService defines three abstract methods, that must be implemented by every Access Methods of AWS. They are:</p> <ul> <li>generateCredentials</li> <li>applyCredentials</li> <li>deApplyCredentials</li> </ul> <pre><code>async generateCredentials(sessionId: string): Promise&lt;CredentialsInfo&gt; {}\n\nasync applyCredentials(sessionId: string, credentialsInfo: CredentialsInfo): Promise&lt;void&gt; {}\n\nasync deApplyCredentials(sessionId: string): Promise&lt;void&gt; {}\n</code></pre> <p>Let's check Start, Stop, and Rotate in detail.</p> <p>Start()</p> <p>The start method is called when a user clicks on an AWS session in the Session List in the Client UI, and it marks the activation of a session thus generating and applying new temporary credentials.</p> <pre><code>async start(sessionId: string): Promise&lt;void&gt; {\n    try {   \n      this.stopAllWithSameNameProfile(sessionId);\n      this.sessionLoading(sessionId);\n      **const credentialsInfo = await this.generateCredentials(sessionId);**\n      **await this.applyCredentials(sessionId, credentialsInfo);**\n      this.sessionActivate(sessionId);\n    } catch (error) {\n      this.sessionError(sessionId, error);\n    }\n  }\n</code></pre> <p>Start method accept a sessionId parameter to retrieve the session to activate. Above is how the Start method is coded in AWS Session Service by means of a template.</p> <p>Using a template ensures that every Access Method for AWS, will need to implement only some specific parts of the code, without compromising the general logic.</p> <p>The steps included are:</p> <ul> <li>Stop all sessions with the same name profile - only one session can be activated with a specific profile name at a time.</li> <li>Put Session state to loadingInBrowser.</li> <li>Generate a set of new temporary credentials for the given session - this is overridden by the specific Access Method.</li> <li>Once obtained the new temporary credentials apply them - this step is also overridden by Access Methods.</li> <li>Finally set Session state to active using sessionActivate() method. This method will also set the startDateTime to the current Date and Time.</li> </ul> <p>In case of an error we call the generic method sessionError which will send relevant error information both to the UI and the log file.</p> <p>Rotate()</p> <pre><code>async rotate(sessionId: string): Promise&lt;void&gt; {\n    try {\n      this.sessionLoading(sessionId);\n      **const credentialsInfo = await this.generateCredentials(sessionId);\n      await this.applyCredentials(sessionId, credentialsInfo);**\n      this.sessionRotated(sessionId);\n    } catch (error) {\n      this.sessionError(sessionId, error);\n    }\n  }\n</code></pre> <p>A similar approach to Start is used with Rotate. Rotate() is called by the Client every time a session is expired (temporary credentials are no longer valid). Calling Rotate will generate a new set of temporary credentials, replacing the old ones.</p> <p>The steps included are:</p> <ul> <li>Put Session state to loadingInBrowser.</li> <li>Generate a set of new temporary credentials for the given session - this is overridden by the specific Access Method.</li> <li>Once obtained the new temporary credentials apply them - this step is also overridden by Access Methods.</li> <li>Finally set Session state to active by calling the sessionRotated() method. This method will also set the startDateTime to the current Date and Time.</li> </ul> <p>In case of an error we call the generic method sessionError which will send relevant error information both to the UI and the log file.</p> <p>Stop()</p> <pre><code>async stop(sessionId: string): Promise&lt;void&gt; {\n    try {\n      **await this.deApplyCredentials(sessionId);**\n      this.sessionDeactivated(sessionId);\n    } catch (error) {\n      this.sessionError(sessionId, error);\n    }\n  }\n</code></pre> <p>The Stop method happens when an error occurs during a call or when the user clicks on an active session. In this case, we de-apply temporary credentials, which in the case of AWS, means removing them from the credential file.</p> <p>Steps here are:</p> <ul> <li>De-apply credentials - this method is overridden by specific implementations of Access Methods, usually involving operations other than removing credentials from credentials file, like removing sensible information from your Secret Vault because they are no longer used.</li> <li>Deactivate the session - which involves putting the Session' state to inactive. The Session will be moved from active session list to general session list in the UI.</li> </ul> <p>As always in case of error, we send general error information to the UI and to the log file via sessionError.</p> <p>To conclude, each Access Method has a specific service that extends AwsSessionService implementing these 3 common methods (generate, apply, and de-apply).</p>","title":"AwsSessionService (Provider Service)"},{"location":"contributing/project-structure/#access-method-session-service","text":"<p>An Access Method generates credentials for the User access to a Cloud Provider, for example, in AWS we have different access methods:</p> <ul> <li>AWS IAM Users</li> <li>AWS IAM Roles Federated</li> <li>AWS IAM Role Chained</li> <li>AWS SSO Role.</li> </ul> <p>Each access method service implements actions to Create, Delete, and Edit this specific Session Type.</p> <p>As the first thing we need to create an interface of all the required information to a specific Access Method:</p> <pre><code>export interface AwsPlainSessionRequest {\n  accountName: string;\n  accessKey: string;\n  secretKey: string;\n  region: string;\n  mfaDevice?: string;\n}\n</code></pre> <p>To set up a specific session from an Access Method we have to create it with a Create method, which uses the interface previously defined:</p> <pre><code>create(accountRequest: AwsPlainSessionRequest, profileId: string): void {\n    const session = new AwsPlainSession(accountRequest.accountName, accountRequest.region, profileId, accountRequest.mfaDevice);\n    this.keychainService.saveSecret(environment.appName, `${session.sessionId}-plain-aws-session-access-key-id`, accountRequest.accessKey);\n    this.keychainService.saveSecret(environment.appName, `${session.sessionId}-plain-aws-session-secret-access-key`, accountRequest.secretKey);\n    this.workspaceService.addSession(session);\n  }\n</code></pre> <p>At the moment edit and delete are defined generally in SessionService, so no need to implement them in an Access Method.</p> <p>To allow using other services to construct our logic we define them in the constructor of the service class.</p> <pre><code>constructor(\n    protected workspaceService: WorkspaceService,\n    private keychainService: KeychainService,\n    private appService: AppService,\n    private fileService: FileService) {\n    super(workspaceService);\n  }\n</code></pre> <p>We also need to define a super(workspaceService) as we are extending AwsSessionService, and thus its constructor.</p> <p>To fulfill its tasks an Access Method must extend AwsSessionService; doing so, will require to implement these three methods:</p> <pre><code>async generateCredentials(sessionId: string): Promise&lt;CredentialsInfo&gt; {}\n\nasync applyCredentials(sessionId: string, credentialsInfo: CredentialsInfo): Promise&lt;void&gt; {}\n\nasync deApplyCredentials(sessionId: string): Promise&lt;void&gt; {}\n</code></pre> <p>They are mandatory, but besides them, a Developer can add to the service class every private or static method he/she would like to organize the code.</p> <p>We present AWS IAM Users Access Method implementation as an example.</p>","title":"Access Method Session Service"},{"location":"contributing/project-structure/#aws-iam-users-access-method","text":"<p>Below we present all the methods implemented in the AWS IAM User Access Method; its purpose is to build temporary IAM STS credentials starting from a standard IAM User credential set.</p> <p>The Set is stored securely upon session creation in the OS Vault and is used at runtime, and only here to generate valid IAM STS temporary credentials.</p> <p>Let's start with two helper methods:</p> <pre><code>static isTokenExpired(tokenExpiration: string): boolean {\n    const now = Date.now();\n    return now &gt; new Date(tokenExpiration).getTime();\n  }\n</code></pre> <p>With isTokenExpired we check the SessionToken expiration given with the temporary credentials to see if they are still valid or not (thus the method returning a boolean).</p> <pre><code>static sessionTokenFromGetSessionTokenResponse(getSessionTokenResponse: GetSessionTokenResponse): { sessionToken: any } {\n    return {\n      sessionToken: {\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        aws_access_key_id: getSessionTokenResponse.Credentials.AccessKeyId.trim(),\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        aws_secret_access_key: getSessionTokenResponse.Credentials.SecretAccessKey.trim(),\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        aws_session_token: getSessionTokenResponse.Credentials.SessionToken.trim(),\n      }\n    };\n  }\n</code></pre> <p>The second helper method constructs a CredentialInfo object to return to the AWSSessionService template for Start() and Rotate(). It is called at the end of the generateCredentials() *method*.</p> <p>It has the SessionTokenResponse from the STS client as the input parameter. It maps all the relevant attributes to the returned object.</p> <pre><code>create(accountRequest: AwsIamUserSessionRequest, profileId: string): void {\n    const session = new AwsIamUserSession(accountRequest.accountName, accountRequest.region, profileId, accountRequest.mfaDevice);\n    this.keychainService.saveSecret(environment.appName, `${session.sessionId}-iam-user-aws-session-access-key-id`, accountRequest.accessKey);\n    this.keychainService.saveSecret(environment.appName, `${session.sessionId}-iam-user-aws-session-secret-access-key`, accountRequest.secretKey);\n    this.workspaceService.addSession(session);\n  }\n</code></pre> <p>Create() is used to construct a new Session as explained before. It calls for a new AwsIamUserSession, passing the properties retrieved from the UI form.</p> <p>A Developer will define a new Model for a Session and that new model will be used here, in case he/she wants to create a new Access Method.</p> <p>In this particular case we also save the static credentials in the OS Vault using the KeyChain service, which makes saving and retrieving secrets from the vault transparent to the developer.</p> <p>Finally, we add the session to the workspace (our configuration object).</p> <pre><code>async generateCredentials(sessionId: string): Promise&lt;CredentialsInfo&gt; {\n      // Get the session in question\n      const session = this.get(sessionId);\n      // Retrieve session token expiration\n      const tokenExpiration = (session as AwsIamUserSession).sessionTokenExpiration;\n      // Check if token is expired\n      if (!tokenExpiration || AwsIamUserService.isTokenExpired(tokenExpiration)) {\n        // Token is Expired!\n        // Retrieve access keys from keychain\n        const accessKeyId = await this.getAccessKeyFromKeychain(sessionId);\n        const secretAccessKey = await this.getSecretKeyFromKeychain(sessionId);\n        // Get session token\n        // https://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html\n        AWS.config.update({ accessKeyId, secretAccessKey });\n        // Configure sts client options\n        const sts = new AWS.STS(this.appService.stsOptions(session));\n        // Configure sts get-session-token api call params\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        const params = { DurationSeconds: environment.sessionTokenDuration };\n        // Check if MFA is needed or not\n        if ((session as AwsIamUserSession).mfaDevice) {\n          // Return session token after calling MFA modal\n          return this.generateSessionTokenCallingMfaModal(session, sts, params);\n        } else {\n          // Return session token in the form of CredentialsInfo\n          return this.generateSessionToken(session, sts, params);\n        }\n      } else {\n        // Session Token is NOT expired\n        try {\n          // Retrieve session token from keychain\n          return JSON.parse(await this.keychainService.getSecret(environment.appName, `${session.sessionId}-iam-user-aws-session-token`));\n        } catch (err) {\n          throw new LeappParseError(this, err.message);\n        }\n      }\n  }\n</code></pre> <p>The first of the abstract methods we need to implement in the Access Method Service. We use this to generate credentials and return them in the form of a Javascript Promise - because the procedure is potentially not immediate and asynchronous.</p> <p>We retrieve the session previously created using the sessionId, which is passed as a parameter; from there we check its token expiration to see if we need to generate new credentials or reuse the one previously created.</p> <p>If we already have a valid session token, we retrieve it from the OS vault, parse the JSON string to construct a valid object to return for further processing. Note that when the return type is a Promise, any normal object will be directly cast to Promise&lt;Object&gt;.</p> <p>If we don't have any token expiration property (first generation) or the token is expired, we retrieve static credentials from the OS vault and use them in combination with the IAM STS client to generate a new Session Token with temporary credentials using</p> <pre><code>this.generateSessionToken(session, sts, params);\n</code></pre> <p>In case we have configured Multi-Factor Authentication, we call for a helper method to show a modal window, retrieve the MFA code, add it to the STS parameters and then obtain the session token.</p> <pre><code>private generateSessionTokenCallingMfaModal( session: Session, sts: AWS.STS, params: { DurationSeconds: number }): Promise&lt;CredentialsInfo&gt; {\n    return new Promise((resolve, reject) =&gt; {\n      this.appService.inputDialog('MFA Code insert', 'Insert MFA Code', 'please insert MFA code from your app or device', (value) =&gt; {\n        if (value !== Constants.confirmClosed) {\n          params['SerialNumber'] = (session as AwsIamUserSession).mfaDevice;\n          params['TokenCode'] = value;\n          // Return session token in the form of CredentialsInfo\n          resolve(this.generateSessionToken(session, sts, params));\n        } else {\n          reject(new LeappMissingMfaTokenError(this, 'Missing Multi Factor Authentication code'));\n        }\n      });\n    });\n  }\n</code></pre> <p>We can see that we return a promise to adhere to the generateCredentials signature.</p> <pre><code>async applyCredentials(sessionId: string, credentialsInfo: CredentialsInfo): Promise&lt;void&gt; {\n    const session = this.get(sessionId);\n    const profileName = this.workspaceService.getProfileName((session as AwsIamUserSession).profileId);\n    const credentialObject = {};\n    credentialObject[profileName] = {\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      aws_access_key_id: credentialsInfo.sessionToken.aws_access_key_id,\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      aws_secret_access_key: credentialsInfo.sessionToken.aws_secret_access_key,\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      aws_session_token: credentialsInfo.sessionToken.aws_session_token,\n      region: session.region\n    };\n    return await this.fileService.iniWriteSync(this.appService.awsCredentialPath(), credentialObject);\n  }\n</code></pre> <p>Applying credentials is just a matter of getting the current profile name for the session, construct a suitable credential object using the profile name and the CredentialInfo object from generateCredentials and write it in the AWS credential file.</p> <pre><code>async deApplyCredentials(sessionId: string): Promise&lt;void&gt; {\n    const session = this.get(sessionId);\n    const profileName = this.workspaceService.getProfileName((session as AwsIamUserSession).profileId);\n    const credentialsFile = await this.fileService.iniParseSync(this.appService.awsCredentialPath());\n    delete credentialsFile[profileName];\n    return await this.fileService.replaceWriteSync(this.appService.awsCredentialPath(), credentialsFile);\n  }\n</code></pre> <p>To de-apply a credential we retrieve its profile name and use it to find and remove the credential set from the credential file.</p> <pre><code>private async getAccessKeyFromKeychain(sessionId: string): Promise&lt;string&gt; {\n    return await this.keychainService.getSecret(environment.appName, `${sessionId}-iam-user-aws-session-access-key-id`);\n}\n\nprivate async getSecretKeyFromKeychain(sessionId: string): Promise&lt;string&gt; {\n    return await this.keychainService.getSecret(environment.appName, `${sessionId}-iam-user-aws-session-secret-access-key`);\n}\n\nprivate async generateSessionToken(session: Session, sts: AWS.STS, params: any): Promise&lt;CredentialsInfo&gt; {\n    try {\n      // Invoke sts get-session-token api\n      const getSessionTokenResponse: GetSessionTokenResponse = await sts.getSessionToken(params).promise();\n\n      // Save session token expiration\n      this.saveSessionTokenResponseInTheSession(session, getSessionTokenResponse);\n\n      // Generate correct object from session token response\n      const sessionToken = AwsIamUserService.sessionTokenFromGetSessionTokenResponse(getSessionTokenResponse);\n\n      // Save in keychain the session token\n      await this.keychainService.saveSecret(environment.appName, `${session.sessionId}-iam-user-aws-session-token`, JSON.stringify(sessionToken));\n\n      // Return Session Token\n      return sessionToken;\n    } catch (err) {\n      throw new LeappAwsStsError(this, err.message);\n    }\n}\n</code></pre> <p>The first two methods are used to simplify getting secrets in the OS vault.</p> <p>generateSessionToken() is used to call STS for generating a new session, save the expiration time from token in the session, save the session token in the OS vault and finally return the session token for further processing.</p> <pre><code>private saveSessionTokenResponseInTheSession(session: Session, getSessionTokenResponse: AWS.STS.GetSessionTokenResponse): void {\n    const index = this.workspaceService.sessions.indexOf(session);\n    const currentSession: Session = this.workspaceService.sessions[index];\n    (currentSession as AwsIamUserSession).sessionTokenExpiration = getSessionTokenResponse.Credentials.Expiration.toISOString();\n    this.workspaceService.sessions[index] = currentSession;\n    this.workspaceService.sessions = [...this.workspaceService.sessions];\n}\n</code></pre> <p>This helper method is used to extract the session token expiration and save it as a property of the session object to later use it in case of a further generation of credentials, both during a rotation event or a manual re-apply.</p>","title":"AWS IAM Users Access Method"},{"location":"installation/install-leapp/","text":"","title":"Install Leapp"},{"location":"installation/install-leapp/#macos-windows-and-linux","text":"<p>You can install Leapp by downloading the pre-built binaries for your OS on the website release page</p> <p>Download Leapp </p> <p>Unzip the package and double-click the executable to install.</p>","title":"MacOS, Windows, and Linux"},{"location":"installation/install-leapp/#macos-homebrew-linux-linuxbrew","text":"<p>Leapp can also be installed on macOS or Linux via Homebrew Cask with: <pre><code>brew install leapp\n</code></pre></p>  <p>Info</p> <p>In addition, Leapp can also be installed with Linuxbrew on Windows via WSL</p>","title":"macOS (Homebrew) &amp; Linux (Linuxbrew)"},{"location":"installation/requirements/","text":"","title":"Requirements"},{"location":"installation/requirements/#macos-and-windows","text":"<p>There are no requirements for macOS and Windows users.</p>","title":"MacOS and Windows"},{"location":"installation/requirements/#linux-systems","text":"<p>Leapp uses <code>libsecret</code> and <code>gnome-keyring</code> as dependencies to store all sensitive data into the keyring. Depending on your distribution, you may need to install them using these commands before running Leapp.</p> Arch LinuxDebian/UbuntuRed Hat-based   <pre><code>sudo pacman -S gnome-keyring\nsudo pacman -S libsecret\n</code></pre>   <pre><code>sudo apt-get install gnome-keyring\nsudo apt-get install libsecret-1-dev\n</code></pre>   <pre><code>sudo yum install gnome-keyring\nsudo yum install libsecret-devel\n</code></pre>","title":"Linux systems"},{"location":"installation/requirements/#logging-into-ec2-instances-via-aws-ssm-with-leapp","text":"<p>In order to use AWS SSM on your System through Leapp, you must be able to execute this command  on your own at least once, when the correct credentials are active.</p> <pre><code>aws ssm start-session --region &lt;region&gt; --target &lt;instanceId&gt;\n</code></pre> <p>If, for any reason, this command fails, please verify that you have Python 3.x installed:</p> <pre><code>https://www.python.org/downloads/\n</code></pre> <p>Also verify that the AWS SSM Agent is installed correctly by following the official AWS guide:</p> <pre><code>https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-agent-v3.html\n</code></pre>","title":"Logging into EC2 Instances via AWS SSM with Leapp"},{"location":"installation/update-leapp/","text":"<p>Leapp checks if a new version is available every 10 minutes (starting from the application launch).  If so, a dialog message will pop up and show a <code>version number</code>, the <code>release date</code> and the <code>changelog</code></p>     <p>In this modal, a user can do the following:</p> Remind me laterDownload updateClick on X   <p>Leapp will close the modal and notify the user that a new update is available by adding a notification dot   to the Dock Bar icon. Users will not be bothered anymore until the next release is available.  This option is convenient for users that want to stick to a specific version.  Note that you can do this for every version and maintain the one you prefer.</p>   <p>Leapp will open the Release URL in your default browser to let the User  manually download the release for their specific OS and install it.</p>   <p>Leapp will close the modal and another one will appear in 10 minutes.</p>","title":"Update Leapp"},{"location":"installation/update-leapp/#macos-homebrew-linux-linuxbrew-and-windows-via-wsl","text":"<p>Leapp can also be updated via Homebrew Cask with: <code>brew upgrade leapp</code></p>","title":"macOS (Homebrew), Linux (Linuxbrew) and Windows (via WSL)"},{"location":"security/intro/","text":"<p>Leapp is built with a security-first approach. Every information that has to be persisted is encrypted and saved on your workstation.</p> <p>We devised two main methods to store data, based on its sensitiveness.</p>    Data Persistence and encryption Examples     Operational All information used to make Leapp work, not strictly tied to direct access to cloud environments. Stored and encrypted in a configuration file within the user workspace. Named profiles, proxy configurations, etc.   Sensitive Information that can be used, or potentially exploited, to gain access to cloud environments. Stored in the System Vault, leveraging its own integrated encryption. Static credentials, access tokens, cached data, etc.","title":"Intro"},{"location":"security/intro/#end-to-end-encryption","text":"<p>We leverage Zero-Knowledge to provide end-to-end encryption on tiers that require to save your data outside of your workstation to deliver specific features.</p> <p>Zero Knowledge is designed so that no one, except you, can access your secured data.</p>  <p>Warning</p> <p>We CAN'T access your data under any circumstances, even if you ask us to!</p>","title":"End-to-end Encryption"},{"location":"security/system-vault/","text":"<p>Information that can be used, or potentially exploited, to gain access to cloud environments are stored your workstation's System Vault, leveraging its own integrated encryption. The user can access the secrets stored in the System Vault at any time, using their user password.</p> <p>Leapp uses Keytar as an interface to the secure vault on macOS, Windows and Linux systems.</p> <p>Every key is stored in the vault under the name Leapp, in the description you will find the underlying name used by Leapp to retrieve the secret.</p>","title":"System Vault"},{"location":"security/system-vault/#supported-system-vaults","text":"OS System Vault     MacOS Keychain   Windows Credential Vault   Linux API/Libsecret     <p>Info</p> <p>We're currently supporting only System Vaults installed by default on the OS. We're planning on extending support to other vaults and online password managers (LastPass, BitWarden, 1Password, etc.).  If you'd like other services to be supported feel free to open an Issue or make a Pull Request (check our contributing guidelines). </p>","title":"Supported System Vaults"},{"location":"security/zero-knowledge/","text":"<p>To persist your configuration online, we implemented Zero-Knowledge encryption to prevent access to your information. But how can you trust a company to keep all of your secrets secret? The answer lies in end-to-end encryption, which lays the groundwork for applications with Zero-Knowledge architectures.</p>  <p>Zero-knowledge refers to policies and architecture that eliminate the possibility for secret managers themselves to access your password.</p>   <p>Warning</p> <p>This is implemented to save your configuration online in the PRO and TEAM versions of Leapp. Don't know yet about the PRO and TEAM versions? Check our roadmap.</p>   <p>Info</p> <p>This same process is leveraged by Bitwarden to store their password. </p>","title":"Zero Knowledge"},{"location":"security/zero-knowledge/#users-have-key-control","text":"<p>When users have complete control of the encryption key, they control access to the data, providing encrypted information to Leapp without Leapp having access to or knowledge of that data.</p>  <p>Info</p> <p>To know more about this, you can find the whitepaper on which we based our implementation of Zero-Knowledge end-to-end encryption.</p>","title":"Users have key control"},{"location":"security/zero-knowledge/#criteria","text":"<p> During any phase of the registration and login process the client does not provide any password-related info to the server. - The server does not store any information that can be used to guess the password in a convenient way. In other words, the system must not be prone to brute force or dictionary attacks. - Any sensible data is encrypted client-side, the server will work with encrypted blocks only. - All the implementation is released as open-source**.</p>","title":"Criteria"},{"location":"security/zero-knowledge/#technologies","text":"<ul> <li>PBKDF2 for client hashing.</li> <li>AES 256 for symmetric cypher.</li> <li>RSA with 4096-bit keys for asymmetric cypher.</li> <li>BCrypt for server hashing.</li> </ul>","title":"Technologies"},{"location":"security/credentials-generation/aws/","text":"<p>Leapp manages 4 types of AWS access methods:</p> <ol> <li>IAM Federated Role</li> <li>IAM User</li> <li>IAM Single Sign-On</li> <li>IAM Role chained</li> </ol> <p>For each access method, Leapp generates a set of <code>temporary credentials</code> through STS and a rotation logic is triggered every 20 minutes.</p> <p>Temporary credentials ensures that no long-term credentials are written in the AWS credentials file located in <code>~/.aws/credentrials</code>.</p> <p>Leapp manages information entered by the user using the following logic for each access method.</p>","title":"AWS"},{"location":"security/credentials-generation/aws/#iam-federated-role","text":"","title":"IAM Federated Role"},{"location":"security/credentials-generation/aws/#assumerolewithsaml","text":"<p>Temporary security credentials created by AssumeRoleWithSAMLResponse last for one hour.  However, you can use the optional DurationSeconds parameter to specify the duration of your session. </p> <p>Your role session lasts for the specified duration, or until the time specified in the SAML authentication response's SessionNotOnOrAfter value, whichever is shorter. You can provide a DurationSeconds value from 900 seconds (15 minutes) up to the maximum session duration setting for the role. This setting can have a value from 1 hour to 12 hours.</p> <p>Leapp sets the token duration to 1 hour.</p>  <p>Info</p> <p>\u26a0\ufe0f In this case, generated credentials are not \"cached\" in the keychain.</p>","title":"assumeRoleWithSAML"},{"location":"security/credentials-generation/aws/#iam-chained-role","text":"<p>An IAM Chained Role is used to access another AWS account services through a main session with a trust relationship.</p> <p>https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/STS.html#assumeRole-property</p> <p>https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html</p> <p>If you do not pass DurationSeconds parameter (as in the case of Leapp), the temporary credentials expire in 1 hour.</p>","title":"IAM Chained Role"},{"location":"security/credentials-generation/aws/#iam-user","text":"<p>The GetSessionToken operation must be called by using the long-term AWS security credentials of the AWS IAM user. Credentials that are created by IAM users are valid for the duration that you specify. This duration can range from 900 seconds (15 minutes) up to a maximum of 129,600 seconds (36 hours), with a default of 43,200 seconds (12 hours). Credentials based on account credentials can range from 900 seconds (15 minutes) up to 3,600 seconds (1 hour), with a default of 1 hour.</p> <p>Leapp sets the token duration to 10 hours.</p>  <p>Info</p> <p>These are the only temporary credentials that are stored in the System vault and not rotated, unless expired.</p>","title":"IAM User"},{"location":"security/credentials-generation/aws/#aws-sso-role","text":"<p>https://aws.amazon.com/premiumsupport/knowledge-center/sso-temporary-credentials/</p>  <p>Info</p> <p>The access token is valid for 8 hours as noted in the expiresAt timestamp in the JSON file. Expired tokens must be re-authenticated using the get-role-credentials API call.</p>  <p>Token duration is fixed to 8 hours.</p>","title":"AWS SSO Role"},{"location":"security/credentials-generation/azure/","text":"","title":"Azure"},{"location":"security/credentials-generation/azure/#azure-credentials-generation","text":"<p>Azure generates a set of access and refresh tokens that are put inside accessTokens.json inside .azure directory.  Following is the procedure used to generate a set of credentials.</p>","title":"Azure credentials generation"},{"location":"security/credentials-generation/azure/#access-strategy-start-session","text":"<p>if accessTokens.json is not present Leapp runs <code>az login \u2014tenant &lt;tenant_id&gt; 2&gt;&amp;1</code>, otherwise accessTokens.json file  is parsed and Leapp extracts the access tokens array.</p> <p>if access token - corresponding to the specific tenant - exists, we extract it or else we run <code>az login</code>.</p> <p>if access token is expired we run <code>az account get-access-token --subscription &lt;subscription-id&gt;</code>.</p> <p>Finally <code>az account set \u2014subscription &lt;subscription-id&gt; 2&gt;&amp;1</code> and <code>az configure \u2014default location &lt;region(location)&gt;</code> are run.</p> <p>Refresh token is deleted from the accessTokens.json file</p>","title":"Access strategy - start session"},{"location":"security/credentials-generation/azure/#access-strategy-rotate-session","text":"<ul> <li>same as start session</li> </ul>","title":"Access strategy - rotate session"},{"location":"security/credentials-generation/azure/#access-strategy-stop-session","text":"<p>We run <code>az account clear</code>, and we set session's status to INACTIVE.</p>  <p>Info</p> <p>Leapp enhances security by forcingly refresh access token every 20 minutes and by removing refresh token from the file.</p>","title":"Access strategy - stop session"},{"location":"troubleshooting/app-data/","text":"","title":"Application Data"},{"location":"troubleshooting/app-data/#default-leapp-directories","text":"<p>Here the user can find all the directories that Leapp uses directly or indirectly.</p>","title":"Default Leapp directories"},{"location":"troubleshooting/app-data/#installation-path","text":"<p>By default, Leapp is installed in the following locations:</p> MacOSLinuxWindows   <pre><code>/Applications\n</code></pre>   <pre><code>/opt/Leapp\n</code></pre>   <pre><code>C:\\Users\\&lt;USER&gt;\\AppData\\Local\\Programs\\Leapp\n</code></pre>","title":"Installation path"},{"location":"troubleshooting/app-data/#configuration-files","text":"<p>By default, Leapp stores the configuration files in the following locations:</p> MacOSLinuxWindows   <pre><code>~/.Leapp\n</code></pre>   <pre><code>~/.Leapp\n</code></pre>   <pre><code>C:\\Users\\&lt;USER&gt;\\.Leapp\n</code></pre>     <p>Info</p> <ul> <li>Leapp-lock.json is used to store your actual configuration and is encrypted.</li> <li>.latest contains the latest version of your Leapp application. In case the file is removed accidentally or intentionally it will be created again when the app is restarted.</li> </ul>","title":"Configuration files"},{"location":"troubleshooting/app-data/#credentials-file","text":"<p>By default, Leapp writes the credentials file in the following locations:</p> MacOSLinuxWindows   <pre><code>~/.aws\n</code></pre>   <pre><code>~/.aws\n</code></pre>   <pre><code>C:\\Users\\&lt;USER&gt;\\.aws\n</code></pre>","title":"Credentials file"},{"location":"troubleshooting/app-data/#logs-file","text":"<p>By default, Leapp writes logs to the following locations:</p> MacOSLinuxWindows   <pre><code>~/Library/Logs/Leapp/log.log\n</code></pre>   <pre><code>~/.config/Leapp/log.log\n</code></pre>   <pre><code>%USERPROFILE%\\\\AppData\\\\Roaming\\\\Leapp\\\\log.log\n</code></pre>     <p>Info</p> <p>Logs are structured in the following way:</p> <pre><code>[YYYY-MM-DD HH:mm:ss.mmm] [LEVEL] [rendered/system] [COMPONENT] MESSAGE {Useful Object / Stacktrace Err Object}\n</code></pre>   <p>Warning</p> <p>Please always add logs to any issue you want to fill whenever possible, so you can help the team identify  the problem quickly</p>","title":"Logs file"},{"location":"troubleshooting/faq/","text":"","title":"FAQ"},{"location":"troubleshooting/faq/#im-using-the-open-source-app-do-you-store-my-data-online","text":"<p>NO.</p> <p>The open-source software don't transfer, persist, or share anything with other services. All your data is secured and encrypted on your workstation.</p> <p>Nobody can access it, not even ourselves.</p>","title":"I'm using the open-source app, do you store my data online?"},{"location":"troubleshooting/faq/#ive-got-a-paid-tier-how-do-you-manage-my-data-can-you-access-it","text":"<p>We can't and don't want to see any of your access data.</p> <p>We need to store your data online to enable some features (syncing, managing other users, etc.) but we implement a Zero-Knowledge encryption system that prevents even ourselves to access your data.</p>","title":"I've got a paid tier, how do you manage my data? Can you access it?"},{"location":"troubleshooting/faq/#i-dont-feel-secure-using-a-built-in-window-for-authentication-cant-you-use-the-default-browser","text":"<p>In the future, Leapp will only use the default browser to authenticate. Right now, this is a compromise to deliver the authentication flow. We already ported the AWS SSO authentication flow on the default browser, and we're working on migrating the other ones as soon as possible.</p>","title":"I don't feel secure using a built-in window for authentication, can't you use the default browser?"},{"location":"troubleshooting/faq/#how-can-i-find-leapp-data-in-the-system-vault","text":"<p>Every key stored by Leapp in the vault is named Leapp. The account name shows the description of the element saved by our software.</p>","title":"How can I find Leapp data in the System Vault?"},{"location":"troubleshooting/faq/#where-do-i-find-the-leapp-logs","text":"<p>Head to the Application data section.</p>","title":"Where do I find the Leapp logs?"}]})